const std = @import("std");

pub fn getRegistry(allocator: std.mem.Allocator, files: []const []const u8) []const u8 { //{{{
    var buf = std.ArrayList(u8).init(allocator);
    buf.writer().print("//! autogenerated file.\n//! do not change.\n//! add to .gitignore if you want\n\n", .{}) catch unreachable;
    outer: for (0..files.len) |file| {
        for (0..file) |i| {
            if (std.mem.eql(u8, files[i], files[file])) {
                continue :outer;
            }
        }
        buf.writer().print("pub const @\"{s}\" = @import(\"{s}\");\n", .{ files[file], files[file] }) catch unreachable;
    }
    return buf.items;
} //}}}

pub fn Param(T: type, name: [:0]const u8, value: T) type { //{{{
    return @Type(.{ .Struct = .{
        .layout = .auto,
        .is_tuple = false,
        .fields = &[_]std.builtin.Type.StructField{.{
            .alignment = @alignOf(T),
            .is_comptime = false,
            .type = T,
            .default_value = &value,
            .name = name,
        }},
        .decls = &[_]std.builtin.Type.Declaration{},
    } });
}

pub fn ParamList(params: anytype) type {
    if (@TypeOf(params) == void) return ParamList(.{});
    var ret: std.builtin.Type = @typeInfo(struct {});
    inline for (params) |P| {
        ret.Struct.fields = ret.Struct.fields ++ @typeInfo(P).Struct.fields;
    }
    return @Type(ret);
} //}}}

pub const Scene = struct { //{{{
    entities: []const Entity = &[_]Entity{},
};

pub const Entity = struct {
    scripts: []const Script = &[_]Script{},
};

pub const Script = union(enum) {
    script: struct {
        path: []const u8,
        data: []const u8, //ZON data
    },
}; //}}}
pub fn getScript(path: []const u8, data: anytype, allocator: std.mem.Allocator) Script { //{{{
    //@compileLog(@typeInfo(data));
    var arraylist = std.ArrayList(u8).init(allocator);
    switch (@TypeOf(data)) {
        type => {
            std.zon.stringify.serialize(data{}, .{}, arraylist.writer()) catch unreachable;
        },
        else => {
            std.zon.stringify.serialize(data, .{}, arraylist.writer()) catch unreachable;
        },
    }
    return .{ .script = .{ .path = path, .data = arraylist.items } };
} //}}}
pub fn makeScene(allocator: std.mem.Allocator, scene: Scene) []const u8 {
    var buf = std.ArrayList(u8).init(allocator);
    buf.writer().print(
        \\pub const std = @import("std"); const This = @This(); pub const registry = @import("registry"); pub var FPS: f64 = 60; var lastFrame: f64 = 0; var deltaTime: f64 = 0; var fixedUpdateTime = 0;
    , .{}) catch unreachable;
    for (0..scene.entities.len) |i| { //{{{
        buf.writer().print("entity{d}: struct{{", .{i}) catch unreachable;
        for (0..scene.entities[i].scripts.len) |x| {
            buf.writer().print(
                \\script{d}: registry.@"{s}" = @import("entity{d}.script{d}.zon"),
            , .{ x, scene.entities[i].scripts[x].script.path, i, x }) catch unreachable;
        }
        buf.writer().print(
            \\pub fn getData(self: @This(), T: type, comptime fieldName: []const u8) !T {{
        , .{}) catch unreachable;
        for (0..scene.entities[i].scripts.len) |x| {
            buf.writer().print(
                \\if (@hasField(@TypeOf(self.script{d}), fieldName)) return @field(self.script{d}, fieldName);
            , .{ x, x }) catch unreachable;
        }
        buf.writer().print(
            \\return error.FieldNotFound;}}pub fn setData(self: *@This(), T: type, value: T, comptime fieldName: []const u8) void {{
        , .{}) catch unreachable;
        for (0..scene.entities[i].scripts.len) |x| {
            buf.writer().print(
                \\if (@hasField(@TypeOf(self.script{d}), fieldName)) @field(self.script{d}, fieldName) = value;
            , .{ x, x }) catch unreachable;
        }
        buf.writer().print(
            \\}} pub fn getScene(self: *@This()) *This {{ return @fieldParentPtr("entity{d}", self); }} }} = .{{}},
        , .{i}) catch unreachable;
    } //}}}

    const funcs = [_][]const u8{ "render", "update", "init", "fixedUpdate", "deinit" }; //{{{
    inline for (funcs) |func| {
        buf.writer().print(
            \\pub fn {s}(self: *This) void {{
        , .{func}) catch unreachable;
        if (std.mem.eql(u8, func, "update")) {
            buf.writer().print(
                \\deltaTime = (std.time.milliTimestamp() - lastFrame) / 1000; lastFrame = std.time.milliTimestamp(); while(fixedUpdateTime < std.time.milliTimestamp() + (1000 / FPS)){{fixedUpdateTime += 1000 / FPS; self.fixedUpdate();}}
            , .{}) catch unreachable;
        }
        if (std.mem.eql(u8, func, "init")) {
            buf.writer().print(
                \\lastFrame = std.time.milliTimestamp(); fixedUpdateTime = std.time.milliTimestamp();
            , .{}) catch unreachable;
        }
        if (std.mem.eql(u8, func, "fixedUpdate")) {
            buf.writer().print(
                \\const time = 1 / FPS;
            , .{}) catch unreachable;
        } else {
            buf.writer().print(
                \\const time = deltaTime;
            , .{}) catch unreachable;
        }
        for (0..scene.entities.len) |entity| {
            for (0..scene.entities[entity].scripts.len) |script| {
                const s = scene.entities[entity].scripts[script].script;

                buf.writer().print("if(@TypeOf(registry.@\"{s}\".{s}) == fn() void)registry.@\"{s}\".{s}();", .{ s.path, func, s.path, func }) catch unreachable;
                buf.writer().print("if(@TypeOf(registry.@\"{s}\".{s}) == fn(registry.@\"{s}\") void)registry.@\"{s}\".{s}(self.entity{d}.script{d});", .{ s.path, func, s.path, s.path, func, entity, script }) catch unreachable;
                buf.writer().print("if(@TypeOf(registry.@\"{s}\".{s}) == fn(*registry.@\"{s}\") void)registry.@\"{s}\".{s}(&self.entity{d}.script{d});", .{ s.path, func, s.path, s.path, func, entity, script }) catch unreachable;

                buf.writer().print("if(@TypeOf(registry.@\"{s}\".{s}) == fn(f64) void)registry.@\"{s}\".{s}(time);", .{ s.path, func, s.path, func }) catch unreachable;
                buf.writer().print("if(@TypeOf(registry.@\"{s}\".{s}) == fn(registry.@\"{s}\", f64) void)registry.@\"{s}\".{s}(self.entity{d}.script{d}, time);", .{ s.path, func, s.path, s.path, func, entity, script }) catch unreachable;
                buf.writer().print("if(@TypeOf(registry.@\"{s}\".{s}) == fn(*registry.@\"{s}\", f64) void)registry.@\"{s}\".{s}(&self.entity{d}.script{d}, time);", .{ s.path, func, s.path, s.path, func, entity, script }) catch unreachable;

                buf.writer().print("if(@TypeOf(registry.@\"{s}\".{s}) == fn(anytype) void)registry.@\"{s}\".{s}(self.entity{d});", .{ s.path, func, s.path, func, entity }) catch unreachable;
                buf.writer().print("if(@TypeOf(registry.@\"{s}\".{s}) == fn(registry.@\"{s}\", anytype) void)registry.@\"{s}\".{s}(self.entity{d}.script{d}, self.entity{d});", .{ s.path, func, s.path, s.path, func, entity, script, entity }) catch unreachable;
                buf.writer().print("if(@TypeOf(registry.@\"{s}\".{s}) == fn(*registry.@\"{s}\", anytype) void)registry.@\"{s}\".{s}(&self.entity{d}.script{d}, self.entity{d});", .{ s.path, func, s.path, s.path, func, entity, script, entity }) catch unreachable;

                buf.writer().print("if(@TypeOf(registry.@\"{s}\".{s}) == fn(f64, anytype) void)registry.@\"{s}\".{s}(time, self.entity{d});", .{ s.path, func, s.path, func, entity }) catch unreachable;
                buf.writer().print("if(@TypeOf(registry.@\"{s}\".{s}) == fn(registry.@\"{s}\", f64, anytype) void)registry.@\"{s}\".{s}(self.entity{d}.script{d}, time, self.entity{d});", .{ s.path, func, s.path, s.path, func, entity, script, entity }) catch unreachable;
                buf.writer().print("if(@TypeOf(registry.@\"{s}\".{s}) == fn(*registry.@\"{s}\", f64, anytype) void)registry.@\"{s}\".{s}(&self.entity{d}.script{d}, time, self.entity{d});", .{ s.path, func, s.path, s.path, func, entity, script, entity }) catch unreachable;

                buf.writer().print("if(@TypeOf(registry.@\"{s}\".{s}) == fn(anytype, f64) void)registry.@\"{s}\".{s}( self.entity{d}, time);", .{ s.path, func, s.path, func, entity }) catch unreachable;
                buf.writer().print("if(@TypeOf(registry.@\"{s}\".{s}) == fn(registry.@\"{s}\", anytype, f64) void)registry.@\"{s}\".{s}(self.entity{d}.script{d}, self.entity{d}, time);", .{ s.path, func, s.path, s.path, func, entity, script, entity }) catch unreachable;
                buf.writer().print("if(@TypeOf(registry.@\"{s}\".{s}) == fn(*registry.@\"{s}\", anytype, f64) void)registry.@\"{s}\".{s}(&self.entity{d}.script{d}, self.entity{d}, time);", .{ s.path, func, s.path, s.path, func, entity, script, entity }) catch unreachable;
            }
        }
        buf.writer().print("}}", .{}) catch unreachable;
    } //}}}
    //std.debug.print("{s}", .{buf.items});
    return buf.items;
}
