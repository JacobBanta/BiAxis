const std = @import("std");
var modules: struct { //{{{
    zon_tool: bool = false,
} = undefined; //}}}

pub fn getRegistry(allocator: std.mem.Allocator, files: []const []const u8) []const u8 { //{{{
    var buf = std.ArrayList(u8).empty;
    var writeBuffer = [_]u8{} ** 64;
    var adapter = buf.writer(allocator).adaptToNewApi(writeBuffer[0..]);
    const writer = &adapter.new_interface;
    _ = writer.write("//! autogenerated file.\n//! do not change.\n//! add to .gitignore if you want\n\n") catch unreachable;
    outer: for (0..files.len) |file| {
        for (0..file) |i| {
            if (std.mem.eql(u8, files[i], files[file])) {
                continue :outer;
            }
        }
        writer.print("pub const @\"{s}\" = @import(\"{s}\");\n", .{ files[file], files[file] }) catch unreachable;
    }
    writer.defaultFlush() catch unreachable;
    return buf.items;
} //}}}

pub fn Param(T: type, name: [:0]const u8, value: T) type { //{{{
    return @Type(.{ .@"struct" = .{
        .layout = .auto,
        .is_tuple = false,
        .fields = &[_]std.builtin.Type.StructField{.{
            .alignment = @alignOf(T),
            .is_comptime = false,
            .type = T,
            .default_value_ptr = &value,
            .name = name,
        }},
        .decls = &[_]std.builtin.Type.Declaration{},
    } });
}

pub fn ParamList(params: anytype) type {
    if (@TypeOf(params) == void) return ParamList(.{});
    var ret: std.builtin.Type = @typeInfo(struct {});
    inline for (params) |P| {
        ret.@"struct".fields = ret.@"struct".fields ++ @typeInfo(P).@"struct".fields;
    }
    return @Type(ret);
} //}}}

pub const Scene = struct { //{{{
    entities: []const Entity = &[_]Entity{},
};

pub const Entity = struct {
    scripts: []const Script = &[_]Script{},
};

pub const Script = union(enum) {
    script: struct {
        path: []const u8,
        data: []const u8, //ZON data
    },
}; //}}}
pub fn getScript(path: []const u8, data: anytype, allocator: std.mem.Allocator) Script { //{{{
    var arraylist = std.ArrayList(u8).empty;
    var writeBuffer = [_]u8{} ** 64;
    var adapter = arraylist.writer(allocator).adaptToNewApi(writeBuffer[0..]);
    const writer = &adapter.new_interface;
    switch (@TypeOf(data)) {
        type => {
            std.zon.stringify.serialize(data{}, .{}, writer) catch unreachable;
        },
        else => {
            std.zon.stringify.serialize(data, .{}, writer) catch unreachable;
        },
    }
    writer.defaultFlush() catch unreachable;
    return .{ .script = .{ .path = path, .data = arraylist.items } };
} //}}}
pub fn makeScene(allocator: std.mem.Allocator, scene: Scene) []const u8 { //{{{
    var buf = std.ArrayList(u8).empty;
    var writeBuffer = [_]u8{} ** 64;
    var adapter = buf.writer(allocator).adaptToNewApi(writeBuffer[0..]);
    const writer = &adapter.new_interface;
    writer.print(
        \\//! autogenerated file.
        \\pub const std = @import("std");
        \\const This = @This();
        \\pub const registry = @import("registry");
        \\pub var FPS: f64 = 60;
        \\var lastFrame: i64 = 0;
        \\var deltaTime: f64 = 0;
        \\var fixedUpdateTime: f64 = 0;
    , .{}) catch unreachable;
    if (modules.zon_tool)
        writer.print("const zon_tool = @import(\"zon_tool\");", .{}) catch unreachable;

    for (0..scene.entities.len) |i| { //{{{
        writer.print("entity{d}: struct{{", .{i}) catch unreachable;
        for (0..scene.entities[i].scripts.len) |x| {
            if (modules.zon_tool) {
                writer.print(
                    \\script{0d}: registry.@"{1s}" = zon_tool.getZon(registry.@"{1s}", @import("entity{2d}.script{0d}.zon")),
                , .{ x, scene.entities[i].scripts[x].script.path, i }) catch unreachable;
            } else {
                writer.print(
                    \\script{d}: registry.@"{s}" = @import("entity{d}.script{0d}.zon"),
                , .{ x, scene.entities[i].scripts[x].script.path, i }) catch unreachable;
            }
        }
        writer.print(
            \\pub inline fn getData(self: @This(), T: type, comptime fieldName: []const u8) !T {{
        , .{}) catch unreachable;
        for (0..scene.entities[i].scripts.len) |x| {
            writer.print(
                \\if (@hasField(@TypeOf(self.script{d}), fieldName)) return @field(self.script{0d}, fieldName);
            , .{x}) catch unreachable;
        }
        writer.print(
            \\return error.FieldNotFound;}}pub fn setData(self: *@This(), T: type, value: T, comptime fieldName: []const u8) void {{
        , .{}) catch unreachable;
        for (0..scene.entities[i].scripts.len) |x| {
            writer.print(
                \\if (@hasField(@TypeOf(self.script{d}), fieldName)) @field(self.script{d}, fieldName) = value;
            , .{ x, x }) catch unreachable;
        }
        writer.print(
            \\}} pub inline fn getScene(self: *@This()) *This {{ return @fieldParentPtr("entity{d}", self); }} }} = .{{}},
        , .{i}) catch unreachable;
    } //}}}

    const funcs = [_][]const u8{ "render", "update", "init", "fixedUpdate", "deinit" }; //{{{
    inline for (funcs) |func| {
        writer.print(
            \\pub inline fn {s}(self: *This) void {{
        , .{func}) catch unreachable;
        if (std.mem.eql(u8, func, "update")) {
            writer.print(
                \\deltaTime = @as(f64, @floatFromInt(std.time.milliTimestamp() - lastFrame)) / 1000;
                \\lastFrame = std.time.milliTimestamp();
                \\while(fixedUpdateTime < @as(f64, @floatFromInt(std.time.milliTimestamp())) + (1000 / FPS)){{fixedUpdateTime += 1000 / FPS;
                \\self.fixedUpdate();
                \\}}
            , .{}) catch unreachable;
        }
        if (std.mem.eql(u8, func, "init")) {
            writer.print(
                \\lastFrame = std.time.milliTimestamp();
                \\fixedUpdateTime = @floatFromInt(std.time.milliTimestamp());
            , .{}) catch unreachable;
        }
        if (std.mem.eql(u8, func, "fixedUpdate")) {
            writer.print(
                \\const time = 1 / FPS;
            , .{}) catch unreachable;
        } else {
            writer.print(
                \\const time = deltaTime;
            , .{}) catch unreachable;
        }
        for (0..scene.entities.len) |entity| {
            for (0..scene.entities[entity].scripts.len) |script| {
                const s = scene.entities[entity].scripts[script].script;
                writer.print(
                    \\if(@hasDecl(registry.@"{0s}", "{1s}")){{
                    \\if(@TypeOf(registry.@"{0s}".{1s}) == fn() void)registry.@"{0s}".{1s}();
                    \\if(@TypeOf(registry.@"{0s}".{1s}) == fn(registry.@"{0s}") void)registry.@"{0s}".{1s}(self.entity{2d}.script{3d});
                    \\if(@TypeOf(registry.@"{0s}".{1s}) == fn(*registry.@"{0s}") void)registry.@"{0s}".{1s}(&self.entity{2d}.script{3d});
                    \\if(@TypeOf(registry.@"{0s}".{1s}) == fn(f64) void)registry.@"{0s}".{1s}(time);
                    \\if(@TypeOf(registry.@"{0s}".{1s}) == fn(registry.@"{0s}", f64) void)registry.@"{0s}".{1s}(self.entity{2d}.script{3d}, time);
                    \\if(@TypeOf(registry.@"{0s}".{1s}) == fn(*registry.@"{0s}", f64) void)registry.@"{0s}".{1s}(&self.entity{2d}.script{3d}, time);
                    \\if(@TypeOf(registry.@"{0s}".{1s}) == fn(anytype) void)registry.@"{0s}".{1s}(&self.entity{2d});
                    \\if(@TypeOf(registry.@"{0s}".{1s}) == fn(registry.@"{0s}", anytype) void)registry.@"{0s}".{1s}(self.entity{2d}.script{3d}, &self.entity{2d});
                    \\if(@TypeOf(registry.@"{0s}".{1s}) == fn(*registry.@"{0s}", anytype) void)registry.@"{0s}".{1s}(&self.entity{2d}.script{3d}, &self.entity{2d});
                    \\if(@TypeOf(registry.@"{0s}".{1s}) == fn(f64, anytype) void)registry.@"{0s}".{1s}(time, &self.entity{2d});
                    \\if(@TypeOf(registry.@"{0s}".{1s}) == fn(registry.@"{0s}", f64, anytype) void)registry.@"{0s}".{1s}(self.entity{2d}.script{3d}, time, &self.entity{2d});
                    \\if(@TypeOf(registry.@"{0s}".{1s}) == fn(*registry.@"{0s}", f64, anytype) void)registry.@"{0s}".{1s}(&self.entity{2d}.script{3d}, time, &self.entity{2d});
                    \\if(@TypeOf(registry.@"{0s}".{1s}) == fn(anytype, f64) void)registry.@"{0s}".{1s}( &self.entity{2d}, time);
                    \\if(@TypeOf(registry.@"{0s}".{1s}) == fn(registry.@"{0s}", anytype, f64) void)registry.@"{0s}".{1s}(self.entity{2d}.script{3d}, &self.entity{2d}, time);
                    \\if(@TypeOf(registry.@"{0s}".{1s}) == fn(*registry.@"{0s}", anytype, f64) void)registry.@"{0s}".{1s}(&self.entity{2d}.script{3d}, &self.entity{2d}, time);
                , .{ s.path, func, entity, script }) catch unreachable;
                writer.print("}}", .{}) catch unreachable;
            }
        }
        writer.print("}}", .{}) catch unreachable;
    } //}}}

    writer.print("pub fn getScripts(self: *@This(), script: type)", .{}) catch unreachable; //{{{
    for (0..scene.entities.len) |entity| {
        outer: for (0..scene.entities[entity].scripts.len) |script| {
            for (0..entity + 1) |entity2| {
                if (entity2 == entity) {
                    for (0..script) |script2| {
                        if (std.mem.eql(
                            u8,
                            scene.entities[entity].scripts[script].script.path,
                            scene.entities[entity2].scripts[script2].script.path,
                        )) {
                            continue :outer;
                        }
                    }
                } else {
                    for (0..scene.entities[entity2].scripts.len) |script2| {
                        if (std.mem.eql(
                            u8,
                            scene.entities[entity].scripts[script].script.path,
                            scene.entities[entity2].scripts[script2].script.path,
                        )) {
                            continue :outer;
                        }
                    }
                }
            }
            var counter: usize = 0;
            for (0..scene.entities.len) |entity2| {
                for (0..scene.entities[entity2].scripts.len) |script2| {
                    if (std.mem.eql(
                        u8,
                        scene.entities[entity].scripts[script].script.path,
                        scene.entities[entity2].scripts[script2].script.path,
                    )) {
                        counter += 1;
                    }
                }
            }
            writer.print(" if(script == registry.@\"{s}\")[{d}]script else", .{ scene.entities[entity].scripts[script].script.path, counter }) catch unreachable;
            writer.print(" if(script == *registry.@\"{s}\")[{d}]script else", .{ scene.entities[entity].scripts[script].script.path, counter }) catch unreachable;
        }
    }
    writer.print("[0]script {{", .{}) catch unreachable;
    for (0..scene.entities.len) |entity| {
        outer: for (0..scene.entities[entity].scripts.len) |script| {
            for (0..entity + 1) |entity2| {
                if (entity2 == entity) {
                    for (0..script) |script2| {
                        if (std.mem.eql(
                            u8,
                            scene.entities[entity].scripts[script].script.path,
                            scene.entities[entity2].scripts[script2].script.path,
                        )) {
                            continue :outer;
                        }
                    }
                } else {
                    for (0..scene.entities[entity2].scripts.len) |script2| {
                        if (std.mem.eql(
                            u8,
                            scene.entities[entity].scripts[script].script.path,
                            scene.entities[entity2].scripts[script2].script.path,
                        )) {
                            continue :outer;
                        }
                    }
                }
            }
            writer.print("if(script == registry.@\"{s}\") return [_]script{{", .{scene.entities[entity].scripts[script].script.path}) catch unreachable;
            for (0..scene.entities.len) |entity2| {
                for (0..scene.entities[entity2].scripts.len) |script2| {
                    if (std.mem.eql(
                        u8,
                        scene.entities[entity].scripts[script].script.path,
                        scene.entities[entity2].scripts[script2].script.path,
                    )) {
                        writer.print("self.entity{d}.script{d}, ", .{ entity2, script2 }) catch unreachable;
                    }
                }
            }
            writer.print("}};", .{}) catch unreachable;

            writer.print("if(script == *registry.@\"{s}\") return [_]script{{", .{scene.entities[entity].scripts[script].script.path}) catch unreachable;
            for (0..scene.entities.len) |entity2| {
                for (0..scene.entities[entity2].scripts.len) |script2| {
                    if (std.mem.eql(
                        u8,
                        scene.entities[entity].scripts[script].script.path,
                        scene.entities[entity2].scripts[script2].script.path,
                    )) {
                        writer.print("&self.entity{d}.script{d}, ", .{ entity2, script2 }) catch unreachable;
                    }
                }
            }
            writer.print("}};", .{}) catch unreachable;
        }
    }

    writer.print("return [0]script{{}};}}", .{}) catch unreachable; //}}}
    writer.defaultFlush() catch unreachable;
    return buf.items;
} //}}}
pub fn addModule(b: *std.Build, scene: Scene, externalImports: []const std.Build.Module.Import, name: []const u8, opts: anytype) Mod { //{{{
    for (externalImports) |i| {
        inline for (@typeInfo(@TypeOf(modules)).@"struct".fields) |f| {
            if (std.mem.eql(u8, i.name, f.name)) {
                @field(modules, f.name) = true;
            }
        }
    }
    var files = std.ArrayList([]const u8).empty;
    for (scene.entities) |entity| {
        for (entity.scripts) |script| {
            files.append(b.allocator, script.script.path) catch unreachable;
        }
    }
    var imports = std.ArrayList(std.Build.Module.Import).empty;
    imports.appendSlice(b.allocator, externalImports) catch unreachable;
    var registry = b.addWriteFile(b.pathFromRoot("registry.zig"), getRegistry(b.allocator, files.items));
    imports.append(b.allocator, .{
        .module = b.createModule(.{ .target = opts.target, .optimize = opts.optimize, .root_source_file = b.path("registry.zig"), .imports = imports.items }),
        .name = "registry",
    }) catch unreachable;
    const writeFiles = b.addWriteFiles();
    const sceneWriteFile = writeFiles.add(name, makeScene(b.allocator, scene));
    for (0..scene.entities.len) |entity| {
        for (0..scene.entities[entity].scripts.len) |script| {
            var file = std.ArrayList(u8).empty;
            file.writer(b.allocator).print("entity{d}.script{d}.zon", .{ entity, script }) catch unreachable;
            _ = writeFiles.add(file.items, scene.entities[entity].scripts[script].script.data);
        }
    }
    const mod = b.addModule(name, .{ .root_source_file = sceneWriteFile, .imports = imports.items, .optimize = opts.optimize, .target = opts.target });
    writeFiles.step.dependOn(&registry.step);
    return .{ .module = mod, .step = &writeFiles.step };
}
const Mod = struct { module: *std.Build.Module, step: *std.Build.Step }; //}}}
