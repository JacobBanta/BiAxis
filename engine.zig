const std = @import("std");

pub fn getRegistry(allocator: std.mem.Allocator, files: []const []const u8) []const u8 { //{{{
    var buf = std.ArrayList(u8).init(allocator);
    buf.writer().print("//! autogenerated file.\n//! do not change.\n//! add to .gitignore if you want\n\n", .{}) catch unreachable;
    outer: for (0..files.len) |file| {
        for (0..file) |i| {
            if (std.mem.eql(u8, files[i], files[file])) {
                continue :outer;
            }
        }
        buf.writer().print("pub const @\"{s}\" = @import(\"{s}\");\n", .{ files[file], files[file] }) catch unreachable;
    }
    return buf.items;
} //}}}

pub fn Param(T: type, name: [:0]const u8, value: T) type { //{{{
    return @Type(.{ .@"struct" = .{
        .layout = .auto,
        .is_tuple = false,
        .fields = &[_]std.builtin.Type.StructField{.{
            .alignment = @alignOf(T),
            .is_comptime = false,
            .type = T,
            .default_value_ptr = &value,
            .name = name,
        }},
        .decls = &[_]std.builtin.Type.Declaration{},
    } });
}

pub fn ParamList(params: anytype) type {
    if (@TypeOf(params) == void) return ParamList(.{});
    var ret: std.builtin.Type = @typeInfo(struct {});
    inline for (params) |P| {
        ret.@"struct".fields = ret.@"struct".fields ++ @typeInfo(P).@"struct".fields;
    }
    return @Type(ret);
} //}}}

pub const Scene = struct { //{{{
    entities: []const Entity = &[_]Entity{},
};

pub const Entity = struct {
    scripts: []const Script = &[_]Script{},
};

pub const Script = union(enum) {
    script: struct {
        path: []const u8,
        data: []const u8, //ZON data
    },
}; //}}}
pub fn getScript(path: []const u8, data: anytype, allocator: std.mem.Allocator) Script { //{{{
    //@compileLog(@typeInfo(data));
    var arraylist = std.ArrayList(u8).init(allocator);
    switch (@TypeOf(data)) {
        type => {
            std.zon.stringify.serialize(data{}, .{}, arraylist.writer()) catch unreachable;
        },
        else => {
            std.zon.stringify.serialize(data, .{}, arraylist.writer()) catch unreachable;
        },
    }
    return .{ .script = .{ .path = path, .data = arraylist.items } };
} //}}}
pub fn makeScene(allocator: std.mem.Allocator, scene: Scene) []const u8 { //{{{
    var buf = std.ArrayList(u8).init(allocator);
    buf.writer().print(
        \\//! autogenerated file.
        \\pub const std = @import("std");
        \\const This = @This();
        \\pub const registry = @import("registry");
        \\pub var FPS: f64 = 60;
        \\var lastFrame: i64 = 0;
        \\var deltaTime: f64 = 0;
        \\var fixedUpdateTime: f64 = 0;
    , .{}) catch unreachable;
    for (0..scene.entities.len) |i| { //{{{
        buf.writer().print("entity{d}: struct{{", .{i}) catch unreachable;
        for (0..scene.entities[i].scripts.len) |x| {
            buf.writer().print(
                \\script{d}: registry.@"{s}" = @import("entity{d}.script{0d}.zon"),
            , .{ x, scene.entities[i].scripts[x].script.path, i }) catch unreachable;
        }
        buf.writer().print(
            \\pub fn getData(self: @This(), T: type, comptime fieldName: []const u8) !T {{
        , .{}) catch unreachable;
        for (0..scene.entities[i].scripts.len) |x| {
            buf.writer().print(
                \\if (@hasField(@TypeOf(self.script{d}), fieldName)) return @field(self.script{0d}, fieldName);
            , .{x}) catch unreachable;
        }
        buf.writer().print(
            \\return error.FieldNotFound;}}pub fn setData(self: *@This(), T: type, value: T, comptime fieldName: []const u8) void {{
        , .{}) catch unreachable;
        for (0..scene.entities[i].scripts.len) |x| {
            buf.writer().print(
                \\if (@hasField(@TypeOf(self.script{d}), fieldName)) @field(self.script{d}, fieldName) = value;
            , .{ x, x }) catch unreachable;
        }
        buf.writer().print(
            \\}} pub fn getScene(self: *@This()) *This {{ return @fieldParentPtr("entity{d}", self); }} }} = .{{}},
        , .{i}) catch unreachable;
    } //}}}

    const funcs = [_][]const u8{ "render", "update", "init", "fixedUpdate", "deinit" }; //{{{
    inline for (funcs) |func| {
        buf.writer().print(
            \\pub fn {s}(self: *This) void {{
        , .{func}) catch unreachable;
        if (std.mem.eql(u8, func, "update")) {
            buf.writer().print(
                \\deltaTime = @as(f64, @floatFromInt(std.time.milliTimestamp() - lastFrame)) / 1000;
                \\lastFrame = std.time.milliTimestamp();
                \\while(fixedUpdateTime < @as(f64, @floatFromInt(std.time.milliTimestamp())) + (1000 / FPS)){{fixedUpdateTime += 1000 / FPS;
                \\self.fixedUpdate();
                \\}}
            , .{}) catch unreachable;
        }
        if (std.mem.eql(u8, func, "init")) {
            buf.writer().print(
                \\lastFrame = std.time.milliTimestamp();
                \\fixedUpdateTime = @floatFromInt(std.time.milliTimestamp());
            , .{}) catch unreachable;
        }
        if (std.mem.eql(u8, func, "fixedUpdate")) {
            buf.writer().print(
                \\const time = 1 / FPS;
            , .{}) catch unreachable;
        } else {
            buf.writer().print(
                \\const time = deltaTime;
            , .{}) catch unreachable;
        }
        for (0..scene.entities.len) |entity| {
            for (0..scene.entities[entity].scripts.len) |script| {
                const s = scene.entities[entity].scripts[script].script;
                buf.writer().print(
                    \\if(@hasDecl(registry.@"{0s}", "{1s}")){{
                    \\if(@TypeOf(registry.@"{0s}".{1s}) == fn() void)registry.@"{0s}".{1s}();
                    \\if(@TypeOf(registry.@"{0s}".{1s}) == fn(registry.@"{0s}") void)registry.@"{0s}".{1s}(self.entity{2d}.script{3d});
                    \\if(@TypeOf(registry.@"{0s}".{1s}) == fn(*registry.@"{0s}") void)registry.@"{0s}".{1s}(&self.entity{2d}.script{3d});
                    \\if(@TypeOf(registry.@"{0s}".{1s}) == fn(f64) void)registry.@"{0s}".{1s}(time);
                    \\if(@TypeOf(registry.@"{0s}".{1s}) == fn(registry.@"{0s}", f64) void)registry.@"{0s}".{1s}(self.entity{2d}.script{3d}, time);
                    \\if(@TypeOf(registry.@"{0s}".{1s}) == fn(*registry.@"{0s}", f64) void)registry.@"{0s}".{1s}(&self.entity{2d}.script{3d}, time);
                    \\if(@TypeOf(registry.@"{0s}".{1s}) == fn(anytype) void)registry.@"{0s}".{1s}(&self.entity{2d});
                    \\if(@TypeOf(registry.@"{0s}".{1s}) == fn(registry.@"{0s}", anytype) void)registry.@"{0s}".{1s}(self.entity{2d}.script{3d}, &self.entity{2d});
                    \\if(@TypeOf(registry.@"{0s}".{1s}) == fn(*registry.@"{0s}", anytype) void)registry.@"{0s}".{1s}(&self.entity{2d}.script{3d}, &self.entity{2d});
                    \\if(@TypeOf(registry.@"{0s}".{1s}) == fn(f64, anytype) void)registry.@"{0s}".{1s}(time, &self.entity{2d});
                    \\if(@TypeOf(registry.@"{0s}".{1s}) == fn(registry.@"{0s}", f64, anytype) void)registry.@"{0s}".{1s}(self.entity{2d}.script{3d}, time, &self.entity{2d});
                    \\if(@TypeOf(registry.@"{0s}".{1s}) == fn(*registry.@"{0s}", f64, anytype) void)registry.@"{0s}".{1s}(&self.entity{2d}.script{3d}, time, &self.entity{2d});
                    \\if(@TypeOf(registry.@"{0s}".{1s}) == fn(anytype, f64) void)registry.@"{0s}".{1s}( &self.entity{2d}, time);
                    \\if(@TypeOf(registry.@"{0s}".{1s}) == fn(registry.@"{0s}", anytype, f64) void)registry.@"{0s}".{1s}(self.entity{2d}.script{3d}, &self.entity{2d}, time);
                    \\if(@TypeOf(registry.@"{0s}".{1s}) == fn(*registry.@"{0s}", anytype, f64) void)registry.@"{0s}".{1s}(&self.entity{2d}.script{3d}, &self.entity{2d}, time);
                , .{ s.path, func, entity, script }) catch unreachable;
                buf.writer().print("}}", .{}) catch unreachable;
            }
        }
        buf.writer().print("}}", .{}) catch unreachable;
    } //}}}
    buf.writer().print("pub fn getScripts(self: *@This(), script: type)", .{}) catch unreachable; //{{{
    for (0..scene.entities.len) |entity| {
        outer: for (0..scene.entities[entity].scripts.len) |script| {
            for (0..entity + 1) |entity2| {
                if (entity2 == entity) {
                    for (0..script) |script2| {
                        if (std.mem.eql(
                            u8,
                            scene.entities[entity].scripts[script].script.path,
                            scene.entities[entity2].scripts[script2].script.path,
                        )) {
                            continue :outer;
                        }
                    }
                } else {
                    for (0..scene.entities[entity2].scripts.len) |script2| {
                        if (std.mem.eql(
                            u8,
                            scene.entities[entity].scripts[script].script.path,
                            scene.entities[entity2].scripts[script2].script.path,
                        )) {
                            continue :outer;
                        }
                    }
                }
            }
            var counter: usize = 0;
            for (0..scene.entities.len) |entity2| {
                for (0..scene.entities[entity2].scripts.len) |script2| {
                    if (std.mem.eql(
                        u8,
                        scene.entities[entity].scripts[script].script.path,
                        scene.entities[entity2].scripts[script2].script.path,
                    )) {
                        counter += 1;
                    }
                }
            }
            buf.writer().print(" if(script == registry.@\"{s}\")[{d}]script else", .{ scene.entities[entity].scripts[script].script.path, counter }) catch unreachable;
            buf.writer().print(" if(script == *registry.@\"{s}\")[{d}]script else", .{ scene.entities[entity].scripts[script].script.path, counter }) catch unreachable;
        }
    }
    buf.writer().print("[0]script {{", .{}) catch unreachable;
    for (0..scene.entities.len) |entity| {
        outer: for (0..scene.entities[entity].scripts.len) |script| {
            for (0..entity + 1) |entity2| {
                if (entity2 == entity) {
                    for (0..script) |script2| {
                        if (std.mem.eql(
                            u8,
                            scene.entities[entity].scripts[script].script.path,
                            scene.entities[entity2].scripts[script2].script.path,
                        )) {
                            continue :outer;
                        }
                    }
                } else {
                    for (0..scene.entities[entity2].scripts.len) |script2| {
                        if (std.mem.eql(
                            u8,
                            scene.entities[entity].scripts[script].script.path,
                            scene.entities[entity2].scripts[script2].script.path,
                        )) {
                            continue :outer;
                        }
                    }
                }
            }
            buf.writer().print("if(script == registry.@\"{s}\") return [_]script{{", .{scene.entities[entity].scripts[script].script.path}) catch unreachable;
            for (0..scene.entities.len) |entity2| {
                for (0..scene.entities[entity2].scripts.len) |script2| {
                    if (std.mem.eql(
                        u8,
                        scene.entities[entity].scripts[script].script.path,
                        scene.entities[entity2].scripts[script2].script.path,
                    )) {
                        buf.writer().print("self.entity{d}.script{d}, ", .{ entity2, script2 }) catch unreachable;
                    }
                }
            }
            buf.writer().print("}};", .{}) catch unreachable;

            buf.writer().print("if(script == *registry.@\"{s}\") return [_]script{{", .{scene.entities[entity].scripts[script].script.path}) catch unreachable;
            for (0..scene.entities.len) |entity2| {
                for (0..scene.entities[entity2].scripts.len) |script2| {
                    if (std.mem.eql(
                        u8,
                        scene.entities[entity].scripts[script].script.path,
                        scene.entities[entity2].scripts[script2].script.path,
                    )) {
                        buf.writer().print("&self.entity{d}.script{d}, ", .{ entity2, script2 }) catch unreachable;
                    }
                }
            }
            buf.writer().print("}};", .{}) catch unreachable;
        }
    }

    buf.writer().print("return [0]script{{}};}}", .{}) catch unreachable; //}}}
    //std.debug.print("{s}", .{buf.items});
    return buf.items;
} //}}}
pub fn addModule(b: *std.Build, scene: Scene, externalImports: []const std.Build.Module.Import, name: []const u8, opts: anytype) Mod { //{{{
    var files = std.ArrayList([]const u8).init(b.allocator);
    for (scene.entities) |entity| {
        for (entity.scripts) |script| {
            files.append(script.script.path) catch unreachable;
        }
    }
    var imports = std.ArrayList(std.Build.Module.Import).init(b.allocator);
    imports.appendSlice(externalImports) catch unreachable;
    var registry = b.addWriteFile(b.pathFromRoot("registry.zig"), getRegistry(b.allocator, files.items));
    imports.append(.{ .module = b.createModule(.{ .target = opts.target, .optimize = opts.optimize, .root_source_file = b.path("registry.zig"), .imports = imports.items }), .name = "registry" }) catch unreachable;
    const sceneWriteFile = b.addWriteFile(std.mem.join(b.allocator, std.fs.path.sep_str, ([_][]const u8{ b.cache_root.path.?, name })[0..]) catch unreachable, makeScene(b.allocator, scene));
    for (0..scene.entities.len) |entity| {
        for (0..scene.entities[entity].scripts.len) |script| {
            var file = std.ArrayList(u8).init(b.allocator);
            file.writer().print("entity{d}.script{d}.zon", .{ entity, script }) catch unreachable;
            const zonWriteFile = b.addWriteFile(std.mem.join(b.allocator, std.fs.path.sep_str, ([_][]const u8{ b.cache_root.path.?, file.items })[0..]) catch unreachable, scene.entities[entity].scripts[script].script.data);
            sceneWriteFile.step.dependOn(&zonWriteFile.step);
        }
    }
    const scenePath = sceneWriteFile.files.items[0].sub_path;
    const mod = b.addModule(name, .{ .root_source_file = std.Build.LazyPath{ .cwd_relative = scenePath }, .imports = imports.items, .optimize = opts.optimize, .target = opts.target });
    sceneWriteFile.step.dependOn(&registry.step);
    return .{ .module = mod, .step = &sceneWriteFile.step };
}
const Mod = struct { module: *std.Build.Module, step: *std.Build.Step }; //}}}
